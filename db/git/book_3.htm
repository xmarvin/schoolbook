<div class="field field-name-body field-type-text-with-summary field-label-hidden">
    <div class="field-items">
        <div property="content:encoded" class="field-item even"><h3>Цели</h3>
            <ul>
                <li>Полная готовность к работе с Git.</li>
            </ul>
            <h2><em>01</em> Установка имени и электронной почты</h2>

            <p>Если вы никогда ранее не использовали git, для начала вам необходимо осуществить установку. Выполните
                следующие команды, чтобы git узнал ваше имя и электронную почту. Если git уже установлен, можете
                переходить к разделу <a
                        href="http://ru.wikipedia.org/wiki/%D0%9F%D0%B5%D1%80%D0%B5%D0%B2%D0%BE%D0%B4_%D1%81%D1%82%D1%80%D0%BE%D0%BA%D0%B8">окончания
                    строк</a>.</p>
            <h4>Выполнить:</h4>
<pre class="instructions">git config --global user.name "Your Name"
git config --global user.email "your_email@whatever.com"</pre>

            <h2><em>02</em> Параметры установки окончаний строк</h2>

            <p>Также, для пользователей Unix/Mac:</p>

            <h4>Выполнить:</h4>

<pre class="instructions">git config --global core.autocrlf input
git config --global core.safecrlf true</pre>

            <p>Для пользователей Windows:</p>

            <h4>Выполнить:</h4>

<pre class="instructions">git config --global core.autocrlf true
git config --global core.safecrlf true</pre>
        </div>
    </div>
</div>


<div class="clearfix" id="page">


    <h1 class="page-title">11. Алиасы</h1>

    <div class="region region-content">
        <div class="block-system" id="block-system-main">


            <div class="content">
                <div typeof="sioc:Item foaf:Document" about="/aliases" class="node node-book clearfix" id="node-12">

                    <div class="node-header">

                    </div>
                    <!-- /.node-header -->

                    <div class="content clearfix">
                        <div class="field field-name-body field-type-text-with-summary field-label-hidden">
                            <div class="field-items">
                                <div property="content:encoded" class="field-item even"><h3>Цели</h3>
                                    <ul>
                                        <li>Научиться настраивать алиасы и шорткаты для команд git</li>
                                    </ul>
                                    <p class="note"><strong>Примечание:</strong> Этот раздел для пользователей
                                        posix-совместимых командных оболочек. Пользователи Windows и других ОС могут
                                        пропустить этот урок, либо попытаться повторить все это с помощью <a
                                                href="http://forum.script-coding.com/viewtopic.php?id=3889">doskey</a>.
                                        Если вы решите пропустить урок, помните, что далее по тексту команда <code>git
                                            hist</code> является алиасом <code>git log --pretty=format:\"%h %ad | %s%d
                                            [%an]\" --graph --date=short</code></p>

                                    <h2><em>01</em> Общие алиасы</h2>

                                    <p>
                                        <ins>git status</ins>
                                        ,
                                        <ins>git add</ins>
                                        ,
                                        <ins>git commit</ins>
                                        ,
                                        <ins>git checkout</ins> &mdash; общие команды, для которых полезно иметь
                                        сокращения.
                                    </p>
                                    <p>Добавьте следующее в файл .gitconfig в вашем $<span class="caps">HOME</span>
                                        каталоге.</p>
                                    <h4>Файл: <em>.gitconfig</em></h4>
<pre class="file">[alias]
  co = checkout
  ci = commit
  st = status
  br = branch
  hist = log --pretty=format:\"%h %ad | %s%d [%an]\" --graph --date=short
  type = cat-file -t
  dump = cat-file -p</pre>

                                    <p>Мы уже успели рассмотреть команды <code>commit</code> и <code>status</code>, в
                                        предыдущем уроке рассмотрели команду <code>log</code> и совсем скоро
                                        познакомимся с <code>checkout</code>. Главное, что стоит запомнить из этого
                                        урока, так это то, что теперь вы можете вводить <code>git st</code> там, где
                                        раньше приходилось использовать <code>git status</code>. Аналогичным образом,
                                        пишем <code>git co</code> вместо <code>git checkout</code> и <code>git ci</code>
                                        вместо <code>git commit</code>. Что лучше всего, команда <code>git hist</code>
                                        позволит избежать ввода очень длинной команды <code>log</code>.</p>

                                    <p>Попробуйте использовать новые команды.</p>

                                    <h2><em>02</em> Задайте алиас <code>hist</code> в файле <code>.gitconfig</code></h2>

                                    <p>По большей части, я буду продолжать печатать полные команды в этом руководстве.
                                        Единственным исключением будет использование алиаса <code>hist</code>,
                                        указанного выше, когда мне понадобится посмотреть git лог. Если вы хотите
                                        повторять мои действия, убедитесь, что алиас <code>hist</code> установлен в
                                        вашем файле <code>.gitconfig</code>.</p>

                                    <h2><em>03</em> <code>Type</code> и <code>Dump</code></h2>

                                    <p>Мы добавили несколько алиасов для команд, которых мы еще не рассматривали. С
                                        командой <code>git branch</code> разберемся чуть позже, а команда <code>git
                                            cat-file</code> используется для исследования git, в чем мы вскоре убедимся.
                                    </p>

                                    <h2><em>04</em> Алиасы команд (опционально)</h2>

                                    <p>Если ваша оболочка поддерживает алиасы или шорткаты, вы можете добавить алиасы и
                                        на этом уровне. Я использую:</p>

                                    <h4>Файл: <em>.profile</em></h4>

<pre class="file">alias gs='git status '
alias ga='git add '
alias gb='git branch '
alias gc='git commit'
alias gd='git diff'
alias go='git checkout '
alias gk='gitk --all&amp;'
alias gx='gitx --all'

alias got='git '
alias get='git '</pre>

                                    <p>Сокращение <code>go</code> для команды <code>git checkout</code> особенно
                                        полезно. Оно позволяет мне вводить:</p>

                                    <pre class="instructions">go &lt;branch&gt;</pre>

                                    <p>для переключения в отдельную ветку.</p>

                                    <p>И да, я достаточно часто пишу вместо <code>git</code> <code>get</code> или <code>got</code>,
                                        поэтому создам алиасы и для них.</p></div>
                            </div>
                        </div>
                        <div class="book-navigation" id="book-navigation-1">
                            <a href="/books/git/chapters/external"> Внешние утилиты</a>
                        </div>
                    </div>
                </div>
                </div>
        </div>
    </div>
    </div>


<div class="section" title="Git через SSH, HTTP">
     <div class="titlepage">
       <div>
         <div>
           <h2 class="title"><a name="_git_ssh_http"></a>Git через
           SSH, HTTP</h2>
         </div>
       </div>
     </div>

     <p>Предположим, у вас есть SSH доступ к веб-серверу, но Git
     не установлен. Git может связываться через HTTP, хотя это и
     менее эффективно, чем его собственный протокол.</p>

     <p>Скачайте, скомпилируйте, установите Git в вашем аккаунте;
     создайте хранилище в каталоге, доступном через web:</p>
     <pre class="literallayout"> $ GIT_DIR=proj.git git init
$ cd proj.git
$ git --bare update-server-info
$ cp hooks/post-update.sample
   hooks/post-update
   </pre>

     <p>Для старых версий Git команда копирования не сработает, и
     вы должны будете запустить</p>
     <pre class="literallayout">$ chmod a+x hooks/post-update
   </pre>

     <p>Теперь вы можете публиковать свои последние правки через
     SSH с любого клона:</p>
     <pre class="literallayout"> $ git push
   веб.сервер:/путь/к/proj.git master
   </pre>

     <p>и кто угодно сможет взять ваш проект с помощью</p>
     <pre class="literallayout">$ git clone http://веб.сервер/proj.git
   </pre>
   </div>

   <div class="section" title="Git через что угодно">
     <div class="titlepage">
       <div>
         <div>
           <h2 class="title"><a name="_git_3"></a>Git через что
           угодно</h2>
         </div>
       </div>
     </div>

     <p>Хотите синхронизировать хранилища без серверов или вообще
     без сетевого подключения? Вынуждены импровизировать на ходу в
     непредвиденной ситуации? Мы видели, как <a class="link" href="ch05.html#makinghistory"><span class="strong"><strong>git
     fast-export</strong></span> и <span class="strong"><strong>git fast-import</strong></span> могут
     преобразовать хранилища в один файл и обратно</a>.
     Посредством обмена такими файлами мы можем переносить
     хранилища git любыми доступными средствами, но есть более
     эффективный инструмент: <span class="strong"><strong>git
     bundle</strong></span>.</p>

     <p>Отправитель создает пакет (bundle):</p>
     <pre class="literallayout">$ git bundle create некий-файл HEAD
   </pre>

     <p>Затем передает «пакет», <code class="literal">некий-файл</code>, другой команде любыми
     средствами, как то: электронная почта, флешка, <span class="strong"><strong>xxd</strong></span> печать и последующее
     распознавание текста, надиктовка битов по телефону, дымовые
     сигналы и так далее. Получатель восстанавливает коммиты из
     пакета, введя</p>
     <pre class="literallayout">$ git pull некий-файл
   </pre>

     <p>Получатель может сделать это даже в пустом хранилище.
     Несмотря на свой небольшой размер, <code class="literal">некий-файл</code> содержит всё исходное хранилище
     Git.</p>

     <p>В больших проектах для устранения излишков объема
     пакетируют только изменения, которых нет в других хранилищах.
     К примеру, пусть коммит «1b6d…» — последний общий для обеих
     групп:</p>
     <pre class="literallayout">$ git bundle create некий-файл HEAD ^1b6d
   </pre>

     <p>Если это делается часто, можно легко забыть, какой коммит
     был отправлен последним. Справка предлагает для решения этой
     проблемы использовать теги. А именно, после передачи пакета
     введите</p>
     <pre class="literallayout">$ git tag -f последний-пакет HEAD
   </pre>

     <p>и создавайте обновленные пакеты с помощью</p>
     <pre class="literallayout">$ git bundle create новый-пакет HEAD ^последний-пакет
   </pre>
   </div>

   <div class="section" title="Патчи: общее применение">
     <div class="titlepage">
       <div>
         <div>
           <h2 class="title"><a name="__49"></a>Патчи: общее
           применение</h2>
         </div>
       </div>
     </div>

     <p>Патчи это тексты изменений, вполне понятные как человеку,
     так и компьютеру. Это делает их очень привлекательным
     форматом обмена. Патч можно послать разработчикам по
     электронной почте, независимо от того, какую систему
     управления версиями они используют. Вашим корреспондентам
     достаточно возможности читать электронную почту, чтобы
     увидеть ваши изменения. Точно так же, с Вашей стороны
     требуется лишь адрес электронной почты: нет нужды в настройке
     онлайн хранилища Git.</p>

     <p>Вспомним из первой главы:</p>
     <pre class="literallayout">$ git diff 1b6d
   </pre>

     <p>выводит патч, который может быть вставлен в письмо для
     обсуждения. В Git хранилище введите</p>
     <pre class="literallayout">$ git apply &lt; мой.patch
   </pre>

     <p>для применения патча.</p>

     <p>В более формальных случаях , когда нужно сохранить имя
     автора и подписи, создавайте соответствующие патчи с заданной
     точки, набрав</p>
     <pre class="literallayout">$ git format-patch 1b6d
   </pre>

     <p>Полученные файлы могут быть отправлены с помощью
     <span class="strong"><strong>git-send-email</strong></span>
     или вручную. Вы также можете указать диапазон коммитов:</p>
     <pre class="literallayout">$ git format-patch 1b6d..HEAD^^
   </pre>

     <p>На принимающей стороне сохраните письмо в файл и
     введите:</p>
     <pre class="literallayout">$ git am &lt; email.txt
   </pre>

     <p>Это применит входящие исправления и создаст коммит,
     включающий имя автора и другую информацию.</p>

     <p>С web-интерфейсом к электронной почте вам, возможно,
     потребуется нажать кнопку, чтобы посмотреть электронную почту
     в своем первоначальном виде перед сохранением патча в
     файл.</p>

     <p>Для клиентов электронной почты, использующих mbox, есть
     небольшие отличия; но если вы используете один из них, то вы,
     по всей видимости, можете легко разобраться в этом без чтения
     описаний!</p>
   </div>

   <div class="section" title="Приносим извинения, мы переехали">
     <div class="titlepage">
       <div>
         <div>
           <h2 class="title"><a name="__50"></a>Приносим
           извинения, мы переехали</h2>
         </div>
       </div>
     </div>

     <p>После клонирования хранилища команды <span class="strong"><strong>git push</strong></span> или <span class="strong"><strong>git pull</strong></span> автоматически
     отправляют и получают его по первоначальному адресу. Каким
     образом Git это делает? Секрет кроется в настройках, заданных
     при создании клона. Давайте взглянем:</p>
     <pre class="literallayout">$ git config --list
   </pre>

     <p>Опция <code class="literal">remote.origin.url</code>
     задает исходный адрес; origin — имя первоначального
     хранилища. Как и имя ветки master, это соглашение. Мы можем
     изменить или удалить это сокращённое имя, но как правило, нет
     причин для этого.</p>

     <p>Если оригинальное хранилище переехало, можно обновить его
     адрес командой</p>
     <pre class="literallayout">$ git config remote.origin.url git://новый.url/proj.git
   </pre>

     <p>Опция <code class="literal">branch.master.merge</code>
     задает удаленную ветку по умолчанию для <span class="strong"><strong>git pull</strong></span>. В ходе
     первоначального клонирования она устанавливается на текущую
     ветку исходного хранилища, так что даже если HEAD исходного
     хранилища впоследствии переместится на другую ветку, pull
     будет верно следовать изначальной ветке.</p>

     <p>Этот параметр обращается только к хранилищу, которое мы
     изначально клонировали и которое записано в параметре
     <code class="literal">branch.master.remote</code>. При
     выполнении pull из других хранилищ мы должны указать нужную
     ветку:</p>
     <pre class="literallayout">$ git pull git://пример.com/other.git master
   </pre>

     <p>Это объясняет, почему некоторых из наших предыдущих
     примеров push и pull не имели аргументов.</p>
   </div>

   <div class="section" title="Удаленные ветки">
     <div class="titlepage">
       <div>
         <div>
           <h2 class="title"><a name="__51"></a>Удаленные
           ветки</h2>
         </div>
       </div>
     </div>

     <p>При клонировании хранилища вы также клонируете все его
     ветки. Вы можете не заметить этого, потому что Git скрывает
     их: вы должны запросить их явно. Это предотвращает
     противоречие между ветками в удаленном хранилище и вашими
     ветками, а также делает Git проще для начинающих.</p>

     <p>Список удаленных веток можно посмотреть командой</p>
     <pre class="literallayout">$ git branch -r
   </pre>

     <p>Вы должны увидеть что-то вроде</p>
     <pre class="literallayout">origin/HEAD
   origin/master
   origin/experimental
   </pre>

     <p>Эти имена отвечают веткам и «голове» в удаленном
     хранилище; их можно использовать в обычных командах Git.
     Например, вы сделали много коммитов, и хотели бы сравнить
     текущее состояние с последней загруженной версией. Вы можете
     искать в журналах нужный SHA1 хеш, но гораздо легче
     набрать</p>
     <pre class="literallayout">$ git diff origin/HEAD
   </pre>

     <p>Также можно увидеть, для чего была создана ветка
     experimental:</p>
     <pre class="literallayout">$ git log origin/experimental
   </pre>
   </div>

   <div class="section" title="Несколько удаленных хранилищ">
     <div class="titlepage">
       <div>
         <div>
           <h2 class="title"><a name="__52"></a>Несколько
           удаленных хранилищ</h2>
         </div>
       </div>
     </div>

     <p>Предположим, что над нашим проектом работают еще два
     разработчика, и мы хотим следить за обоими. Мы можем
     наблюдать более чем за одним хранилищем одновременно, вот
     так:</p>
     <pre class="literallayout">$ git remote add other git://пример.com/некое_хранилище.git
   $ git pull other некая_ветка
   </pre>

     <p>Сейчас мы сделали слияние с веткой из второго хранилища.
     Теперь у нас есть легкий доступ ко всем веткам во всех
     хранилищах:</p>
     <pre class="literallayout"> $ git diff origin/experimental^
   other/некая_ветка~5
   </pre>

     <p>Но что если мы просто хотим сравнить их изменения, не
     затрагивая свою работу? Иными словами, мы хотим изучить чужие
     ветки, не давая их изменениям вторгаться в наш рабочий
     каталог. Тогда вместо pull наберите</p>
     <pre class="literallayout"> $ git fetch # Перенести из origin, по
   умолчанию.
$ git fetch other # Перенести от
   второго программиста.
   </pre>

     <p>Так мы лишь переносим их историю. Хотя рабочий каталог
     остается нетронутыми, мы можем обратиться к любой ветке в
     любом хранилище команды, работающей с Git, так как теперь у
     нас есть локальная копия.</p>

     <p>Держим в уме, что pull это просто <span class="strong"><strong>fetch</strong></span>, а затем <span class="strong"><strong>merge</strong></span>. Обычно мы используем
     <span class="strong"><strong>pull</strong></span>, потому что
     мы хотим влить к себе последний коммит после получения чужой
     ветки. Описанная ситуация — примечательное исключение.</p>

     <p>О том, как отключить удаленные хранилища, игнорировать
     отдельные ветки и многом другом смотрите в <span class="strong"><strong>git help remote</strong></span>.</p>
   </div>

